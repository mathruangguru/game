<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Substitute the Operator</title>
    
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@300;400;600&family=Nunito:wght@400;700;900&display=swap" rel="stylesheet">

    <style>
        :root {
            /* Palette matching the reference */
            --bg-color: #2b1055; 
            --bg-gradient: radial-gradient(circle at center, #4b1d85 0%, #2b1055 100%);
            --p1-color: #00d2ff; 
            --p1-dark: #009ac2;
            --p1-bg: rgba(0, 210, 255, 0.15);
            --p2-color: #ff47bc; 
            --p2-dark: #c2007e;
            --p2-bg: rgba(255, 71, 188, 0.15);
            --card-bg: #ffffff;
            --card-text: #2b1055;
            --text-color: #ffffff;
            --op-bg: #ffd700;
            --op-text: #5a3e00;
        }

        * {
            box-sizing: border-box;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            background-image: var(--bg-gradient);
            color: var(--text-color);
            font-family: 'Nunito', sans-serif;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            display: flex;
            flex-direction: column;
        }

        /* --- UTILS --- */
        .hidden { display: none !important; }
        .flex-center { display: flex; justify-content: center; align-items: center; }
        
        /* --- SCREENS --- */
        #start-screen, #game-over-screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(20, 5, 40, 0.95);
            backdrop-filter: blur(10px);
            z-index: 100;
            /* Scroll improvements */
            overflow-y: auto; 
            overflow-x: hidden;
            display: flex;
            align-items: center; /* Center vertically for TV look */
            justify-content: center;
            -webkit-overflow-scrolling: touch;
        }

        /* Wrapper to handle safe vertical centering + scrolling */
        .content-wrapper {
            margin: auto;
            width: 100%;
            max-width: 900px; /* Limit width for TV */
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px; /* Reduced padding */
            text-align: center;
        }

        h1 {
            font-family: 'Fredoka', cursive;
            font-size: 2.2rem; /* Optimized for 540p */
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 10px;
            color: #fff;
            text-shadow: 3px 3px 0px #000, 0 0 15px var(--p1-color);
            line-height: 1.1;
        }

        .input-group {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            align-items: center;
            flex-wrap: wrap;
            justify-content: center;
            transition: all 0.3s;
        }

        .name-input {
            font-family: 'Fredoka', cursive;
            font-size: 1rem;
            padding: 8px 15px;
            border-radius: 50px;
            border: 2px solid #fff;
            background: rgba(255,255,255,0.1);
            color: #fff;
            text-align: center;
            width: 180px;
            transition: all 0.3s;
        }
        .name-input:focus { outline: none; background: rgba(255,255,255,0.2); }
        #input-p1 { border-color: var(--p1-color); }
        #input-p2 { border-color: var(--p2-color); }

        /* Mode & Difficulty Selector */
        .selector-label {
            margin-bottom: 5px; 
            color: #ddd; 
            font-family: 'Fredoka'; 
            font-size: 0.9rem;
            margin-top: 5px;
        }

        .toggle-container {
            display: flex;
            gap: 8px;
            margin-bottom: 5px;
            background: rgba(255,255,255,0.1);
            padding: 4px;
            border-radius: 50px;
        }
        .toggle-btn {
            background: transparent;
            border: 2px solid transparent;
            color: rgba(255,255,255,0.6);
            padding: 6px 15px;
            border-radius: 40px;
            font-family: 'Fredoka', cursive;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        .toggle-btn.active {
            background: #ffd700;
            color: #5a3e00;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            font-weight: bold;
        }

        .btn-start {
            font-family: 'Fredoka', cursive;
            background: linear-gradient(180deg, #ffd700, #ffaa00);
            border: 2px solid #fff;
            padding: 8px 30px;
            font-size: 1.4rem;
            font-weight: 600;
            color: #5a3e00;
            border-radius: 60px;
            cursor: pointer;
            box-shadow: 0 4px 0 #b37700;
            margin-top: 10px;
        }
        .btn-start:active { transform: translateY(4px); box-shadow: 0 0 0 #b37700; }

        /* --- HUD --- */
        header {
            height: 70px; /* Fixed small height for 540p */
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 20px;
            background: rgba(0,0,0,0.3);
            border-bottom: 1px solid rgba(255,255,255,0.1);
            position: relative;
            transition: all 0.3s;
            flex-shrink: 0; /* Don't shrink */
        }
        
        /* Single Player Specific HUD Styles */
        body.single-mode header {
            justify-content: center;
        }
        body.single-mode #p2-panel, 
        body.single-mode .vs-separator {
            display: none !important;
        }
        body.single-mode #p1-panel {
            width: auto;
            min-width: 250px;
            border: 2px solid #ffd700;
            background: rgba(0,0,0,0.4);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.2);
        }

        .player-stats {
            display: flex;
            flex-direction: column;
            width: 35%;
            padding: 5px 10px;
            border-radius: 12px;
            background: rgba(255,255,255,0.1);
            transition: all 0.3s ease;
            position: relative;
        }

        .turn-badge {
            position: absolute;
            top: -10px;
            left: 50%;
            transform: translateX(-50%);
            background: #fff;
            color: #2b1055;
            padding: 1px 8px;
            border-radius: 8px;
            font-family: 'Fredoka', cursive;
            font-size: 0.7rem;
            font-weight: bold;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            white-space: nowrap;
            opacity: 0;
            z-index: 20;
            transition: opacity 0.3s;
        }
        .active-turn .turn-badge { opacity: 1; }

        .player-timer {
            position: absolute;
            top: 2px;
            font-family: 'Fredoka', monospace;
            font-size: 0.9rem;
            font-weight: bold;
            color: rgba(255,255,255,0.5);
            background: rgba(0,0,0,0.3);
            padding: 1px 6px;
            border-radius: 6px;
        }
        #p1-time-display { right: 5px; }
        #p2-time-display { left: 5px; }

        .player-name { 
            font-family: 'Fredoka', cursive;
            font-size: 1rem;
            color: #fff;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-top: 10px; /* Adjusted for smaller header */
        }
        
        .hearts { display: flex; gap: 3px; margin-top: 2px; }
        .p2-stats .hearts { justify-content: flex-end; }
        .heart { 
            font-size: 1rem;
            color: #ff3333; 
        }
        .heart.lost { opacity: 0.2; filter: grayscale(100%); }

        .p1-stats { border: 2px solid var(--p1-color); }
        .active-turn.p1-stats { background: var(--p1-bg); box-shadow: 0 0 15px var(--p1-color); }

        .p2-stats { border: 2px solid var(--p2-color); text-align: right; }
        .active-turn.p2-stats { background: var(--p2-bg); box-shadow: 0 0 15px var(--p2-color); }
        
        .inactive-turn { opacity: 0.5; filter: grayscale(80%); transform: scale(0.95); }

        /* Winstreak Counter */
        .streak-container {
            position: absolute;
            bottom: -8px;
            background: #ffd700;
            color: #5a3e00;
            font-family: 'Fredoka', cursive;
            font-weight: bold;
            border-radius: 10px;
            padding: 1px 6px;
            font-size: 0.7rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.4);
            opacity: 0;
            transition: opacity 0.3s;
        }
        .p1-stats .streak-container { right: 5px; }
        .p2-stats .streak-container { left: 5px; }
        .streak-active { opacity: 1; }

        /* --- GAME ARENA --- */
        #arena {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 10px;
            position: relative;
            /* Ensure it fits in 540p minus header/footer */
        }

        /* Message Overlay (e.g. "Dilempar ke Lawan") */
        #message-overlay {
            position: absolute;
            top: 5%;
            background: rgba(255, 0, 0, 0.8);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-family: 'Fredoka', cursive;
            font-size: 1.2rem;
            z-index: 50;
            pointer-events: none;
            opacity: 0;
            transform: translateY(-20px);
            transition: all 0.3s;
        }
        #message-overlay.show { opacity: 1; transform: translateY(0); }

        /* Countdown Bar for the 40s turn limit */
        .turn-timer-bar {
            width: 70%;
            height: 6px;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            margin-bottom: 25px; /* space for text above */
            overflow: hidden;
            position: relative;
        }
        .turn-timer-fill {
            height: 100%;
            background: #00ff88;
            width: 100%;
            transition: width 1s linear;
        }
        .turn-timer-text {
            position: absolute;
            top: -20px;
            width: 100%;
            text-align: center;
            font-family: 'Fredoka';
            color: #fff;
            font-size: 1rem;
        }

        /* Puzzle Board */
        .equation-board {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            gap: 10px;
            background: rgba(255,255,255,0.1);
            padding: 15px 30px;
            border-radius: 15px;
            border: 2px solid rgba(255,255,255,0.2);
            margin-bottom: 20px;
            max-width: 95%;
            box-shadow: 0 5px 20px rgba(0,0,0,0.3);
        }

        .num-slot {
            font-family: 'Fredoka', sans-serif;
            font-size: 2.2rem; /* Adjusted for 540p */
            color: #fff;
            font-weight: 600;
            min-width: 30px;
            text-align: center;
        }

        .operator-slot {
            width: 50px;
            height: 50px;
            background: rgba(0,0,0,0.3);
            border: 2px dashed rgba(255,255,255,0.4);
            border-radius: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: all 0.2s;
        }
        
        .operator-slot.filled {
            border-style: solid;
            border-color: #ffd700;
            background: rgba(255,215,0,0.2);
        }

        /* Draggable Operators */
        .operator-bank {
            display: flex;
            gap: 20px;
            padding: 10px 20px;
            background: rgba(255,255,255,0.9);
            border-radius: 50px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        .draggable-op {
            width: 50px;
            height: 50px;
            background: linear-gradient(135deg, #ffd700, #ffaa00);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            /* Font update for LaTeX look */
            font-family: 'Times New Roman', serif; 
            font-size: 1.8rem;
            font-weight: normal;
            color: #5a3e00;
            cursor: grab;
            box-shadow: 0 3px 0 #b37700;
            touch-action: none; 
            position: relative;
            z-index: 10;
        }

        .draggable-op:active {
            cursor: grabbing;
            transform: scale(1.1);
        }

        .draggable-op.used {
            opacity: 0.3;
            filter: grayscale(100%);
            pointer-events: none;
            box-shadow: none;
            transform: translateY(3px);
        }

        /* Visual clone during drag */
        .drag-clone {
            position: fixed;
            pointer-events: none;
            z-index: 1000;
            opacity: 0.9;
            transform: scale(1.2);
            font-family: 'Times New Roman', serif;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2rem;
            color: #5a3e00;
            background: #ffd700;
            border-radius: 50%;
        }

        .op-in-slot {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Times New Roman', serif;
            font-size: 2rem;
            color: #ffd700;
            font-weight: bold;
            cursor: pointer;
        }

        /* Feedback Animation */
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-10px); }
            75% { transform: translateX(10px); }
        }
        .shake { animation: shake 0.4s ease-in-out; }

        @keyframes pop {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }
        .pop { animation: pop 0.3s ease-out; }

        footer {
            height: 30px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: rgba(255,255,255,0.4);
            font-size: 0.7rem;
            flex-shrink: 0;
        }

    </style>
</head>
<body>

    <!-- Start Screen -->
    <div id="start-screen">
        <div class="content-wrapper">
            <h1>Substitute<br><span style="font-size:0.5em; color:#ffd700; font-family:'Nunito';">The Operator</span></h1>
            
            <div class="selector-label">Mode Permainan:</div>
            <div class="toggle-container">
                <button class="toggle-btn" onclick="game.setMode('single')" id="btn-mode-single">1 Player</button>
                <button class="toggle-btn active" onclick="game.setMode('multi')" id="btn-mode-multi">2 Players</button>
            </div>

            <div class="input-group" id="input-container">
                <input type="text" id="input-p1" class="name-input" placeholder="Player 1" maxlength="8">
                <span id="vs-text" style="font-family: 'Fredoka'; font-size: 1.2rem; color: #fff;">VS</span>
                <input type="text" id="input-p2" class="name-input" placeholder="Player 2" maxlength="8">
            </div>

            <div class="selector-label">Pilih Tingkat Kesulitan:</div>
            <div class="toggle-container">
                <button class="toggle-btn active" onclick="game.setDifficulty('easy')" id="btn-diff-easy">Mudah</button>
                <button class="toggle-btn" onclick="game.setDifficulty('medium')" id="btn-diff-medium">Sedang</button>
                <button class="toggle-btn" onclick="game.setDifficulty('hard')" id="btn-diff-hard">Sulit</button>
            </div>

            <div id="rules-text" style="margin-bottom: 10px; font-size: 0.85rem; max-width: 500px; line-height: 1.4; color: #ddd; background: rgba(0,0,0,0.5); padding: 10px 15px; border-radius: 10px; text-align: left;">
                <p style="text-align: center; margin-top: 0; margin-bottom: 5px;">üßÆ <strong>Aturan Main (2 Player):</strong></p>
                <ul style="margin: 5px 0 5px 20px; padding: 0;">
                    <li>Isi operator (+, &minus;, &times;, &divide;) agar hasilnya benar.</li>
                    <li>Setiap operator hanya boleh dipakai <strong>sekali</strong>.</li>
                    <li>Jika salah, soal <strong>dilempar ke lawan</strong>!</li>
                </ul>
                <p style="color:#ffd700; font-weight:bold; text-align: center; margin-bottom: 0;">üèÜ Menang = Winstreak 3x atau Bertahan!</p>
            </div>
            <button class="btn-start" onclick="game.init()">MULAI</button>
        </div>
    </div>

    <!-- Game Over Screen -->
    <div id="game-over-screen" class="hidden">
        <div class="content-wrapper">
            <h1 id="end-title" style="color: #ffd700;">GAME OVER</h1>
            <h2 id="winner-text" style="color: #fff; margin-bottom: 15px; font-family:'Fredoka'; font-size: 2rem;">Player 1 Wins!</h2>
            <div id="end-reason" style="color: #ccc; margin-bottom: 25px; font-size: 1.2rem;">Reason</div>
            <button class="btn-start" onclick="location.reload()">MAIN LAGI</button>
        </div>
    </div>

    <!-- HUD -->
    <header>
        <!-- Player 1 -->
        <div id="p1-panel" class="player-stats p1-stats active-turn">
            <div class="turn-badge">GILIRANMU</div>
            <span id="p1-time-display" class="player-timer">03:00</span>
            <span class="player-name" id="hud-name-p1">Player 1</span>
            <div class="hearts" id="p1-hearts">
                <span class="heart">‚ù§</span><span class="heart">‚ù§</span><span class="heart">‚ù§</span>
            </div>
            <div class="streak-container" id="p1-streak">Streak: 0</div>
        </div>

        <!-- Center VS / Round -->
        <div class="vs-separator" style="text-align: center; opacity: 0.7;">
            <div style="font-family:'Fredoka'; font-size: 1.2rem; color:#ffd700;">VS</div>
        </div>

        <!-- Player 2 -->
        <div id="p2-panel" class="player-stats p2-stats inactive-turn">
            <div class="turn-badge">GILIRANMU</div>
            <span id="p2-time-display" class="player-timer">03:00</span>
            <span class="player-name" id="hud-name-p2">Player 2</span>
            <div class="hearts" id="p2-hearts">
                <span class="heart">‚ù§</span><span class="heart">‚ù§</span><span class="heart">‚ù§</span>
            </div>
            <div class="streak-container" id="p2-streak">Streak: 0</div>
        </div>
    </header>

    <!-- Game Arena -->
    <section id="arena">
        <div id="message-overlay">LEMPAR KE LAWAN!</div>
        <div class="turn-timer-text">Waktu Soal: <span id="turn-timer-val">40</span>s</div>
        <div class="turn-timer-bar">
            <div id="turn-fill" class="turn-timer-fill"></div>
        </div>

        <!-- The Puzzle -->
        <div class="equation-board" id="equation-container">
            <!-- Dynamically generated slots go here -->
        </div>

        <!-- Draggable Operators -->
        <div class="operator-bank" id="operator-bank">
            <!-- Using HTML entities for LaTeX-like appearance -->
            <div class="draggable-op" data-op="+" onmousedown="dragStart(event)" ontouchstart="dragStart(event)">+</div>
            <div class="draggable-op" data-op="-" onmousedown="dragStart(event)" ontouchstart="dragStart(event)">&minus;</div>
            <div class="draggable-op" data-op="*" onmousedown="dragStart(event)" ontouchstart="dragStart(event)">&times;</div>
            <div class="draggable-op" data-op="/" onmousedown="dragStart(event)" ontouchstart="dragStart(event)">&divide;</div>
        </div>
    </section>

    <footer>
        Substitute the Operator (TV Version)
    </footer>

    <script>
        // --- Audio Context ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function playTone(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            
            const now = audioCtx.currentTime;
            if(type === 'snap') {
                osc.frequency.setValueAtTime(400, now);
                osc.frequency.exponentialRampToValueAtTime(800, now + 0.1);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(now); osc.stop(now + 0.1);
            } else if (type === 'win') {
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(300, now);
                osc.frequency.linearRampToValueAtTime(600, now + 0.2);
                gain.gain.setValueAtTime(0.2, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
                osc.start(now); osc.stop(now + 0.5);
            } else if (type === 'lose') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(150, now);
                osc.frequency.linearRampToValueAtTime(100, now + 0.3);
                gain.gain.setValueAtTime(0.2, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                osc.start(now); osc.stop(now + 0.3);
            } else if (type === 'pass') { 
                osc.type = 'sine';
                osc.frequency.setValueAtTime(600, now);
                osc.frequency.linearRampToValueAtTime(400, now + 0.3);
                gain.gain.setValueAtTime(0.1, now);
                osc.start(now); osc.stop(now + 0.3);
            }
        }

        // --- Logic ---
        const GameConfig = {
            turnTime: 40,
            totalTime: 180, // 3 mins
            lives: 3,
            singlePlayerGoal: 5
        };

        const state = {
            mode: 'multi', // 'single' or 'multi'
            difficulty: 'easy', 
            p1: { name: 'Player 1', time: GameConfig.totalTime, lives: GameConfig.lives, streak: 0 },
            p2: { name: 'Player 2', time: GameConfig.totalTime, lives: GameConfig.lives, streak: 0 },
            activePlayer: 'p1',
            currentPuzzle: null,
            placedOperators: {},
            turnTimer: GameConfig.turnTime,
            intervals: { global: null, turn: null },
            isProcessing: false,
            isRebound: false
        };

        const els = {
            start: document.getElementById('start-screen'),
            over: document.getElementById('game-over-screen'),
            board: document.getElementById('equation-container'),
            fill: document.getElementById('turn-fill'),
            timerText: document.getElementById('turn-timer-val'),
            p1Panel: document.getElementById('p1-panel'),
            p2Panel: document.getElementById('p2-panel'),
            msgOverlay: document.getElementById('message-overlay'),
            inputP2: document.getElementById('input-p2'),
            vsText: document.getElementById('vs-text'),
            rules: document.getElementById('rules-text')
        };

        // Helper to convert Code Operators to LaTeX-style visual
        function getVisualOp(op) {
            if (op === '*') return '&times;';
            if (op === '/') return '&divide;';
            if (op === '-') return '&minus;';
            return op;
        }

        const game = {
            setMode: (mode) => {
                state.mode = mode;
                
                // Update Buttons
                document.getElementById('btn-mode-single').classList.toggle('active', mode === 'single');
                document.getElementById('btn-mode-multi').classList.toggle('active', mode === 'multi');

                // Update UI visibility
                if(mode === 'single') {
                    els.inputP2.style.display = 'none';
                    els.vsText.style.display = 'none';
                    els.rules.innerHTML = `
                    <p style="text-align: center; margin-top: 0; margin-bottom: 5px;">üßÆ <strong>Aturan Main (1 Player):</strong></p>
                    <ul style="margin: 5px 0 5px 20px; padding: 0;">
                        <li>Isi operator agar hasilnya benar.</li>
                        <li>Kumpulkan <strong>Streak ${GameConfig.singlePlayerGoal}</strong> untuk menang.</li>
                        <li>Nyawa habis = Game Over.</li>
                        <li>Waktu tetap 40 detik per soal.</li>
                    </ul>
                    `;
                } else {
                    els.inputP2.style.display = 'block';
                    els.vsText.style.display = 'block';
                    els.rules.innerHTML = `
                    <p style="text-align: center; margin-top: 0; margin-bottom: 5px;">üßÆ <strong>Aturan Main (2 Player):</strong></p>
                    <ul style="margin: 5px 0 5px 20px; padding: 0;">
                        <li>Isi operator agar hasilnya benar.</li>
                        <li>Setiap operator hanya boleh dipakai <strong>sekali</strong>.</li>
                        <li>Jika salah, soal <strong>dilempar ke lawan</strong>!</li>
                    </ul>
                    <p style="color:#ffd700; font-weight:bold; text-align: center; margin-bottom: 0;">üèÜ Menang = Winstreak 3x atau Bertahan!</p>
                    `;
                }
            },

            setDifficulty: (diff) => {
                state.difficulty = diff;
                // Update Buttons
                document.querySelectorAll('[id^="btn-diff-"]').forEach(btn => btn.classList.remove('active'));
                document.getElementById(`btn-diff-${diff}`).classList.add('active');
            },

            init: () => {
                const n1 = document.getElementById('input-p1').value.trim();
                const n2 = document.getElementById('input-p2').value.trim();
                if(n1) state.p1.name = n1;
                if(n2) state.p2.name = n2;

                document.getElementById('hud-name-p1').innerText = state.p1.name;
                document.getElementById('hud-name-p2').innerText = state.p2.name;

                // Configure HUD for Single Player
                if (state.mode === 'single') {
                    document.body.classList.add('single-mode');
                    // Hide timer element in single player if not needed, or keep for aesthetics
                    document.getElementById('p1-time-display').style.opacity = '0'; 
                } else {
                    document.body.classList.remove('single-mode');
                    document.getElementById('p1-time-display').style.opacity = '1';
                }

                els.start.classList.add('hidden');
                
                // Start Timers
                // Only global timer for multiplayer essentially, but we run it for single too
                state.intervals.global = setInterval(game.tickGlobal, 1000);
                game.newRound();
            },

            newRound: () => {
                state.isProcessing = false;
                state.isRebound = false; 
                state.turnTimer = GameConfig.turnTime;
                state.placedOperators = {}; // Reset container
                
                // Reset UI for round
                game.updateTurnUI();
                game.generatePuzzle();
                game.renderBoard();
                game.resetBank();
                
                // Start Turn Timer
                if(state.intervals.turn) clearInterval(state.intervals.turn);
                state.intervals.turn = setInterval(game.tickTurn, 100); 
            },

            tickGlobal: () => {
                if (state.mode === 'single') return; // Disable global timer for single player

                const p = state.activePlayer;
                state[p].time--;
                
                const min = Math.floor(state[p].time / 60).toString().padStart(2, '0');
                const sec = (state[p].time % 60).toString().padStart(2, '0');
                document.getElementById(`${p}-time-display`).innerText = `${min}:${sec}`;

                if(state[p].time <= 0) {
                    game.endGame(p === 'p1' ? 'p2' : 'p1', 'Waktu Habis!');
                }
            },

            tickTurn: () => {
                state.turnTimer -= 0.1;
                const pct = (state.turnTimer / GameConfig.turnTime) * 100;
                els.fill.style.width = `${pct}%`;
                els.timerText.innerText = Math.ceil(state.turnTimer);

                els.fill.style.background = pct < 25 ? '#ff3333' : '#00ff88';

                if(state.turnTimer <= 0) {
                    game.handleMistake("Waktu Habis!");
                }
            },

            switchTurn: (newPuzzle = true) => {
                if (state.mode === 'single') {
                    // Single Player Flow
                    if (newPuzzle) {
                        game.newRound();
                    } else {
                        // Retry current puzzle (resetting)
                        state.isProcessing = false;
                        state.turnTimer = GameConfig.turnTime;
                        state.placedOperators = {};
                        game.renderBoard();
                        game.resetBank();
                        if(state.intervals.turn) clearInterval(state.intervals.turn);
                        state.intervals.turn = setInterval(game.tickTurn, 100);
                        
                        // Show "COBA LAGI" overlay
                        els.msgOverlay.innerText = "COBA LAGI!";
                        els.msgOverlay.classList.add('show');
                        setTimeout(() => els.msgOverlay.classList.remove('show'), 1500);
                    }
                } else {
                    // Multi Player Flow
                    state.activePlayer = state.activePlayer === 'p1' ? 'p2' : 'p1';
                    
                    if (newPuzzle) {
                        game.newRound();
                    } else {
                        // Logic for Rebound
                        state.isProcessing = false;
                        state.turnTimer = GameConfig.turnTime;
                        state.placedOperators = {}; // Reset answers
                        
                        game.updateTurnUI();
                        game.renderBoard(); 
                        game.resetBank(); 
                        
                        if(state.intervals.turn) clearInterval(state.intervals.turn);
                        state.intervals.turn = setInterval(game.tickTurn, 100);
                        
                        // Show Overlay Message
                        els.msgOverlay.innerText = "LEMPAR KE LAWAN!";
                        els.msgOverlay.classList.add('show');
                        setTimeout(() => els.msgOverlay.classList.remove('show'), 2000);
                    }
                }
            },

            generatePuzzle: () => {
                const opsPool = ['+', '-', '*', '/'];
                let valid = false;
                let payload = {};

                // Determine counts based on difficulty
                let numCount = 2; // Default Easy
                let opCount = 1;
                
                if(state.difficulty === 'medium') {
                    numCount = 3; opCount = 2;
                } else if(state.difficulty === 'hard') {
                    numCount = 4; opCount = 3;
                }

                while(!valid) {
                    // Distinct operators: shuffle and slice
                    const shuffledOps = opsPool.sort(() => 0.5 - Math.random()).slice(0, opCount);
                    
                    // Generate numbers
                    const nums = Array.from({length: numCount}, () => Math.floor(Math.random() * 9) + 1);
                    
                    // Build expression string for eval
                    let expr = `${nums[0]}`;
                    for(let i=0; i < opCount; i++) {
                        expr += ` ${shuffledOps[i]} ${nums[i+1]}`;
                    }

                    const res = eval(expr); 

                    // Validation: Integer, Positive, Not too huge
                    if (Number.isInteger(res) && res >= 0 && res <= 80) {
                        valid = true;
                        payload = { nums, ops: shuffledOps, res, opCount };
                    }
                }
                state.currentPuzzle = payload;
            },

            renderBoard: () => {
                const { nums, res } = state.currentPuzzle;
                let html = '';
                
                // Loop to build board based on number of nums
                for(let i = 0; i < nums.length; i++) {
                    html += `<div class="num-slot">${nums[i]}</div>`;
                    
                    // Add operator slot if not the last number
                    if(i < nums.length - 1) {
                        html += `<div class="operator-slot" data-idx="${i}" onmouseup="drop(event)" ontouchend="drop(event)"></div>`;
                        // Initialize placeholder in state
                        state.placedOperators[i] = null;
                    }
                }

                html += `<div class="num-slot">=</div>`;
                html += `<div class="num-slot" style="color:#ffd700">${res}</div>`;
                
                els.board.innerHTML = html;
            },

            resetBank: () => {
                const bank = document.getElementById('operator-bank');
                Array.from(bank.children).forEach(child => {
                    child.classList.remove('used');
                    child.style.display = 'flex';
                });
            },

            checkSolution: () => {
                // Check if all slots for current puzzle are filled
                const requiredOps = state.currentPuzzle.opCount;
                let filledCount = 0;
                for(let i=0; i<requiredOps; i++) {
                    if(state.placedOperators[i]) filledCount++;
                }

                if(filledCount < requiredOps) return;

                state.isProcessing = true;
                clearInterval(state.intervals.turn); 

                const p = state.activePlayer;
                const { nums, res, opCount } = state.currentPuzzle;
                
                // Build User Expression
                let expr = `${nums[0]}`;
                for(let i=0; i<opCount; i++) {
                    const op = state.placedOperators[i];
                    expr += ` ${op} ${nums[i+1]}`;
                }

                const userRes = eval(expr);

                if (userRes === res) {
                    // Correct!
                    playTone('win');
                    state[p].streak++;
                    document.getElementById(`${p}-streak`).innerText = `Streak: ${state[p].streak}`;
                    document.getElementById(`${p}-streak`).classList.add('streak-active');

                    els.board.classList.add('pop');
                    setTimeout(() => els.board.classList.remove('pop'), 300);

                    // Win Condition Logic
                    const winGoal = state.mode === 'single' ? GameConfig.singlePlayerGoal : 3;
                    
                    if(state[p].streak >= winGoal) {
                        if (state.mode === 'single') {
                            game.endGame(p, `Hebat! Streak ${winGoal} Tercapai!`);
                        } else {
                            game.endGame(p, "Winstreak 3x!");
                        }
                    } else {
                        setTimeout(() => game.switchTurn(true), 1000);
                    }
                } else {
                    // Wrong
                    game.handleMistake("Jawaban Salah!");
                }
            },

            handleMistake: (reason) => {
                playTone('lose');
                const p = state.activePlayer;
                state[p].lives--;
                state[p].streak = 0; // Reset streak on mistake
                
                const hearts = document.getElementById(`${p}-hearts`).children;
                if(hearts[state[p].lives]) hearts[state[p].lives].classList.add('lost');
                document.getElementById(`${p}-streak`).innerText = `Streak: 0`;
                document.getElementById(`${p}-streak`).classList.remove('streak-active');

                els.board.classList.add('shake');
                setTimeout(() => els.board.classList.remove('shake'), 500);

                if(state[p].lives <= 0) {
                    if (state.mode === 'single') {
                        game.endGame(p, "Yah, Nyawa Kamu Habis!");
                    } else {
                        game.endGame(p === 'p1' ? 'p2' : 'p1', "Lawan Kehabisan Nyawa!");
                    }
                } else {
                    if (state.mode === 'single') {
                        // Single Player: Retry same puzzle
                        setTimeout(() => {
                            game.switchTurn(false); // false = retry same puzzle
                        }, 1000);
                    } else {
                        // Multiplayer: Throw to opponent logic
                        if (!state.isRebound) {
                            state.isRebound = true; 
                            setTimeout(() => {
                                playTone('pass');
                                game.switchTurn(false); 
                            }, 1000);
                        } else {
                            // Both failed -> New Round
                            setTimeout(() => game.switchTurn(true), 1000);
                        }
                    }
                }
            },

            updateTurnUI: () => {
                if (state.mode === 'single') {
                    // Always active for P1
                    els.p1Panel.className = 'player-stats p1-stats active-turn';
                } else {
                    const isP1 = state.activePlayer === 'p1';
                    els.p1Panel.className = isP1 ? 'player-stats p1-stats active-turn' : 'player-stats p1-stats inactive-turn';
                    els.p2Panel.className = !isP1 ? 'player-stats p2-stats active-turn' : 'player-stats p2-stats inactive-turn';
                }
                
                els.fill.style.width = '100%';
                els.fill.style.background = '#00ff88';
            },

            endGame: (winnerKey, reason) => {
                clearInterval(state.intervals.global);
                clearInterval(state.intervals.turn);
                
                const winnerName = state[winnerKey].name;
                els.over.classList.remove('hidden');
                
                if (state.mode === 'single') {
                    if (state[winnerKey].lives > 0) {
                        // Win
                        document.getElementById('end-title').innerText = "YOU WIN!";
                        document.getElementById('winner-text').innerText = `${winnerName} Hebat!`;
                    } else {
                        // Loss
                        document.getElementById('end-title').innerText = "GAME OVER";
                        document.getElementById('winner-text').innerText = "Coba Lagi Ya!";
                    }
                } else {
                    document.getElementById('winner-text').innerText = `${winnerName} Menang!`;
                }
                
                document.getElementById('end-reason').innerText = reason;
                
                document.getElementById('end-title').style.color = winnerKey === 'p1' ? 'var(--p1-color)' : 'var(--p2-color)';
            }
        };

        // --- Drag & Drop System ---
        let dragSrc = null;
        let dragClone = null;
        let touchOffset = { x:0, y:0 };

        function dragStart(e) {
            if(state.isProcessing) return;
            
            const evt = e.type === 'touchstart' ? e.touches[0] : e;
            const target = e.currentTarget; 
            
            if(target.classList.contains('used')) return;

            dragSrc = target;
            
            // Create Clone
            dragClone = target.cloneNode(true);
            dragClone.classList.add('drag-clone');
            dragClone.style.width = target.offsetWidth + 'px';
            dragClone.style.height = target.offsetHeight + 'px';
            document.body.appendChild(dragClone);

            const rect = target.getBoundingClientRect();
            const centerX = rect.left + rect.width/2;
            const centerY = rect.top + rect.height/2;

            touchOffset.x = evt.clientX - centerX;
            touchOffset.y = evt.clientY - centerY;

            updateClonePos(evt.clientX, evt.clientY);

            if (e.type === 'touchstart') {
                document.addEventListener('touchmove', dragMove, {passive: false});
                document.addEventListener('touchend', dragEnd);
            } else {
                document.addEventListener('mousemove', dragMove);
                document.addEventListener('mouseup', dragEnd);
            }
        }

        function dragMove(e) {
            e.preventDefault(); 
            const evt = e.type === 'touchmove' ? e.touches[0] : e;
            updateClonePos(evt.clientX, evt.clientY);
        }

        function updateClonePos(x, y) {
            if(dragClone) {
                dragClone.style.left = (x - (dragClone.offsetWidth/2)) + 'px';
                dragClone.style.top = (y - (dragClone.offsetHeight/2)) + 'px';
            }
        }

        function drop(e) {
            // Handled in dragEnd
        }

        function dragEnd(e) {
            document.removeEventListener('touchmove', dragMove);
            document.removeEventListener('touchend', dragEnd);
            document.removeEventListener('mousemove', dragMove);
            document.removeEventListener('mouseup', dragEnd);

            if (!dragClone || !dragSrc) return;

            const evt = e.type === 'touchend' ? e.changedTouches[0] : e;
            
            dragClone.style.display = 'none';
            let elemBelow = document.elementFromPoint(evt.clientX, evt.clientY);
            dragClone.style.display = 'flex';

            let dropZone = elemBelow ? elemBelow.closest('.operator-slot') : null;

            if (dropZone && !dropZone.classList.contains('filled')) {
                const op = dragSrc.dataset.op;
                const idx = dropZone.dataset.idx;

                playTone('snap');
                state.placedOperators[idx] = op;
                
                dragSrc.classList.add('used');

                // Use helper to display LaTeX-style symbol in the slot
                const visualOp = getVisualOp(op);
                dropZone.innerHTML = `<div class="op-in-slot" onclick="removeOp(${idx})">${visualOp}</div>`;
                dropZone.classList.add('filled');
                
                game.checkSolution();
            }

            dragClone.remove();
            dragClone = null;
            dragSrc = null;
        }

        window.removeOp = (idx) => {
            if(state.isProcessing) return;

            const op = state.placedOperators[idx];
            if(!op) return;

            const bank = document.getElementById('operator-bank');
            const srcBtn = Array.from(bank.children).find(el => el.dataset.op === op);
            if(srcBtn) srcBtn.classList.remove('used');

            const slot = document.querySelector(`.operator-slot[data-idx="${idx}"]`);
            slot.innerHTML = '';
            slot.classList.remove('filled');
            state.placedOperators[idx] = null;
            
            playTone('snap');
        };

    </script>
</body>
</html>
